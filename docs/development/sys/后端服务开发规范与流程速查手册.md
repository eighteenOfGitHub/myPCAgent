
### **后端服务开发规范与流程速查手册**

**核心思想**

1.  **分层架构**: 将代码逻辑清晰地分离到不同的层中，实现关注点分离。
2.  **后端函数实现与 API 分离**: 业务逻辑与接口定义解耦，提高可维护性、可测试性和可重用性。
3.  **遵循项目规范**: 严格遵守 `AI编程规范.md` 中的 Python 编写标准。

**项目结构**

```text
.
├── backend/                  # 后端服务主目录
│   ├── api/                  # API 接口层 (与框架耦合)
│   │   ├── __init__.py
│   │   ├── api_router.py     # API 的主路由器 (聚合各模块路由)
│   │   └── endpoints/        # API 端点定义层
│   │       ├── __init__.py
│   │       └── module_name.py # 例如: user.py, product.py, order.py
│   ├── config/
│   │   └── settings.py       # 应用配置管理
│   ├── logs/                 # 日志文件 (由 settings 配置)
│   ├── core/                 # 核心业务逻辑层 (与框架无关)
│   │   ├── __init__.py
│   │   └── other_core_modules.py
│   ├── services/             # 业务服务层 (核心逻辑实现)
│   │   ├── __init__.py
│   │   └── service_name.py   # 例如: user_service.py, product_service.py, order_service.py
│   └── main.py               # FastAPI 应用入口
├── shared/                   # 前后端共享模块
│   └── schemas.py            # 共享的 Pydantic 模型 (请求/响应模型)
├── frontend/                 # 前端服务主目录
│   └── app.py
└── main.py                   # 项目主启动文件
```

**开发流程**

**1. 设计业务逻辑 (Service Layer):**

*   **位置**: `backend/services/service_name.py` (例如 `backend/services/user_service.py`)
*   **原则**:
    *   专注于业务逻辑本身，与 FastAPI 框架无关。
    *   函数参数和返回值使用简单的 Python 类型或 Pydantic 模型实例。
    *   使用 `async def` 定义异步函数（如果涉及 I/O 操作）。
    *   编写清晰的函数文档字符串 (Docstring)。
    *   遵循 `AI编程规范` (命名、类型提示、错误处理等)。
*   **示例 (User Service)**:
    ```python
    # backend/services/user_service.py

    from typing import Dict, Any, List, Optional
    from backend.db_models.user import User as UserDBModel # 引入数据库模型
    from sqlmodel import Session, select # 假设使用 SQLModel

    class UserService:
        def __init__(self, session: Session):
            self.session = session # 依赖注入 Session

        def get_user_by_id(self, user_id: int) -> Optional[UserDBModel]:
            """
            根据 ID 获取用户。

            Args:
                user_id (int): 用户 ID。

            Returns:
                Optional[UserDBModel]: 用户数据库模型实例，未找到则返回 None。
            """
            statement = select(UserDBModel).where(UserDBModel.id == user_id)
            return self.session.exec(statement).first()

        def create_user(self, username: str, email: str) -> UserDBModel:
            """
            创建新用户。

            Args:
                username (str): 用户名。
                email (str): 邮箱。

            Returns:
                UserDBModel: 保存到数据库的用户实例。
            """
            # ... 实现创建和保存逻辑 ...
            new_user = UserDBModel(username=username, email=email)
            self.session.add(new_user)
            self.session.commit()
            self.session.refresh(new_user) # 获取数据库生成的 ID 等
            return new_user

        # ... 其他方法如 get_all_users, update_user, delete_user ...
    ```
    *   **注意**: Service 类通常会接收数据库 Session 或其他依赖项作为构造函数参数，实现依赖注入。业务逻辑层直接操作数据库模型 (`UserDBModel`)。

**2. 定义共享模型 (Schemas):**

*   **位置**: `shared/schemas.py`
*   **原则**:
    *   **只定义用于 API 交互的请求体和响应体模型**。
    *   **不得在 API 端点中直接使用数据库模型 (`backend/db_models` 中的模型) 进行校验或序列化**。API 端点必须使用 `shared/schemas.py` 中定义的模型。
    *   使用 `pydantic.BaseModel` 定义请求体、响应体。
    *   为 API 端点提供数据校验和序列化。
    *   响应模型通常不包含敏感字段（如密码哈希），或使用 `Field(exclude=True)` 排除。
*   **示例 (User Schemas)**:
    ```python
    # shared/schemas.py

    from pydantic import BaseModel, Field
    from typing import Optional

    # --- 请求体模型 (用于创建/更新) ---
    class UserCreate(BaseModel):
        username: str = Field(..., min_length=3, max_length=50, description="用户名")
        email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$', description="邮箱地址")
        password: str = Field(..., min_length=8, description="密码")

    class UserUpdate(BaseModel):
        username: Optional[str] = Field(None, min_length=3, max_length=50, description="用户名")
        email: Optional[str] = Field(None, regex=r'^[\w\.-]+@[\w\.-]+\.\w+$', description="邮箱地址")

    # --- 响应体模型 (用于返回给客户端) ---
    class UserResponse(BaseModel): # API 端点返回的模型
        id: int
        username: str
        email: str
        # 注意：不包含 'password' 等敏感信息
        # created_at: datetime # 如果数据库模型中有此字段，且需要返回

        class Config:
            from_attributes = True # 允许从 ORM 对象（如 SQLModel 实例）创建 Pydantic 模型实例

    # --- 其他通用响应模型 ---
    class MessageResponse(BaseModel):
        message: str
    ```
    *   **注意**: `UserResponse` 不包含 `password` 字段，确保敏感信息不被暴露。`from_attributes=True` 对于从 ORM 模型（如 SQLModel）实例创建 Pydantic 响应模型非常有用。

**3. 创建 API 端点 (Endpoint Layer):**

*   **位置**: `backend/api/endpoints/module_name.py` (例如 `backend/api/endpoints/user.py`)
*   **原则**:
    *   使用 `fastapi.APIRouter` 定义路由。
    *   **负责数据校验**：使用 `shared/schemas.py` 中定义的**请求体模型**。
    *   **负责返回响应**：使用 `shared/schemas.py` 中定义的**响应体模型**。
    *   负责调用服务层函数、处理异常。
    *   使用 `response_model` 指定响应格式（必须是 `shared/schemas.py` 中的模型）。
    *   遵循 `AI编程规范`。
*   **示例 (User Endpoints)**:
    ```python
    # backend/api/endpoints/user.py

    from fastapi import APIRouter, HTTPException, Depends
    from typing import List
    from backend.services.user_service import UserService
    from shared.schemas import UserCreate, UserUpdate, UserResponse, MessageResponse
    from backend.db.session import get_session # 假设这是获取数据库 Session 的依赖项
    from sqlmodel import Session

    router = APIRouter(prefix="/users", tags=["Users"])

    # --- 创建用户 ---
    @router.post("", response_model=UserResponse) # URL: /api/users/
    def create_user(
        user_data: UserCreate, # 使用 shared.schemas 中的请求体模型进行校验
        session: Session = Depends(get_session) # 依赖注入 Session
    ):
        """
        创建一个新用户。
        """
        service = UserService(session) # 传入 Session
        try:
            # 调用服务层逻辑，服务层内部使用数据库模型 (UserDBModel)
            created_user_db_model = service.create_user(
                username=user_data.username,
                email=user_data.email
            )
            # FastAPI 自动将数据库模型实例 (UserDBModel) 转换为响应模型实例 (UserResponse)
            # 这依赖于 UserResponse.Config.from_attributes = True
            return created_user_db_model # 返回数据库模型实例，FastAPI 会处理转换

        except ValueError as e:
            # 处理 service.create_user 可能抛出的 ValueError
            raise HTTPException(status_code=400, detail=str(e))
        except Exception as e:
            # 处理其他意外错误
            raise HTTPException(status_code=500, detail=f"创建用户失败: {str(e)}")

    # --- 获取用户详情 ---
    @router.get("/{user_id}", response_model=UserResponse) # URL: /api/users/{user_id}
    def get_user(
        user_id: int,
        session: Session = Depends(get_session)
    ):
        """
        根据 ID 获取用户信息。
        """
        service = UserService(session)
        user_db_model = service.get_user_by_id(user_id)
        if not user_db_model:
            raise HTTPException(status_code=404, detail="用户不存在")
        
        # 返回数据库模型实例，FastAPI 会根据 response_model (UserResponse) 进行转换
        return user_db_model

    # ... 其他端点 ...
    ```
    *   **注意**: API 端点层负责调用服务层 (`UserService`) 的方法。它接收 `shared.schemas.UserCreate` 进行请求体校验，并使用 `shared.schemas.UserResponse` 作为返回类型。服务层内部操作数据库模型，API 层负责将数据库模型转换为共享的响应模型（利用 `from_attributes=True`）。

**4. 聚合 API 路由 (API Router):**

*   **位置**: `backend/api/api_router.py`
*   **原则**:
    *   创建主 `APIRouter` 实例 (通常不设置 `prefix`)。
    *   使用 `include_router` 将各功能模块的路由器聚合进来。
*   **示例**:
    ```python
    # backend/api/api_router.py

    from fastapi import APIRouter
    from backend.api.endpoints import user # 导入端点路由器

    api_router = APIRouter(tags=["api"])
    api_router.include_router(user.router) # 包含端点路由
    # api_router.include_router(product.router) # 包含其他模块路由

    ```
    *   **注意**: 这里没有给 `user.router` 添加额外前缀，所以用户相关的 API 路径就是 `/api/users/...`。

**5. 启动 FastAPI 应用 (Main):**

*   **位置**: `backend/main.py`
*   **原则**:
    *   创建 `FastAPI` 实例。
    *   添加中间件（如 `CORSMiddleware`）。
    *   使用 `app.include_router(api_router, prefix="/api")` 加载 API 路由。
    *   通过 `uvicorn` 启动应用。
*   **示例**:
    ```python
    # backend/main.py

    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    from backend.api.api_router import api_router
    from backend.config.settings import settings

    app = FastAPI(title="My App API")

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.ALLOWED_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.include_router(api_router, prefix="/api") # 加载路由

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="127.0.0.1", port=8000)

    ```
    *   **注意**: 最终的 API 路径会是 `/api/users/...`。

**关键要点**

1.  **分离**: 业务逻辑 (`services`) 和 API 接口 (`api/endpoints`) 必须分离。
2.  **聚合**: 使用 `api_router.py` 作为 `main.py` 和具体 `endpoints` 之间的桥梁。
3.  **模型职责分离**:
    *   **共享模型 (`shared/schemas.py`)**: 仅用于 API 的**请求体校验**和**响应体定义**。
    *   **数据库模型 (`backend/db_models`)**: 仅用于数据库交互和业务逻辑实现。
    *   **API 端点** 必须使用共享模型，**不得**直接使用数据库模型。
4.  **聚合**: 使用 `api_router.py` 作为 `main.py` 和具体 `endpoints` 之间的桥梁。
5.  **规范**: 时刻遵守 `AI编程规范`，确保代码质量和一致性。
6.  **测试**: 分离后的 `services` 层更容易进行单元测试。
7.  **依赖注入**: 在 API 端点中使用 `Depends` 来注入服务层所需的依赖（如数据库 Session），提高代码的可测试性和解耦性。