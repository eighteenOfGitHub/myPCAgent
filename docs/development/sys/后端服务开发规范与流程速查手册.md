### **后端服务开发规范与流程速查手册**

**核心思想**

1.  **分层架构**: 将代码逻辑清晰地分离到不同的层中,实现关注点分离。
2.  **后端函数实现与 API 分离**: 业务逻辑与接口定义解耦,提高可维护性、可测试性和可重用性。
3.  **响应体模型按端点拆分**: 将共享模型按 API 端点模块化组织,避免单一文件过度膨胀。
4.  **遵循项目规范**: 严格遵守 `AI编程规范.md` 中的 Python 编写标准。

**项目结构**

```text
Project Root/
├── .gitignore                 # Git 忽略规则文件
├── requirements.txt          # 项目依赖库列表
├── README.md                 # 项目说明文档
├── start_script.*            # 启动脚本 (例如 start.bat, start.sh)
├── config_files/             # 存放各类配置文件
│   ├── environment_config.*  # 环境变量配置 (YAML, JSON, .env 等)
│   └── ...                   # 其他配置文件 (日志、数据库等)
├── documentation/            # 项目文档
│   ├── development/          # 开发相关文档
│   │   └── ...               # 如开发规范、API 文档等
│   └── notes/                # 开发笔记
│       ├── errors/           # 错误记录与解决方案
│       └── systematic/       # 系统性笔记
├── source_code/              # 源代码主目录
│   ├── main.py              # 应用入口文件 (FastAPI/Flask/Django main)
│   ├── api/                 # API 相关代码
│   │   ├── endpoints/       # API 路由定义 (视图函数)
│   │   └── router.py        # API 路由聚合器
│   ├── core/                # 核心业务逻辑与基础配置
│   │   ├── config/          # 项目核心配置
│   │   ├── utils/           # 通用工具函数
│   │   ├── database.py      # 数据库连接与初始化
│   │   └── logger.py        # 日志系统配置
│   ├── data/                # 数据文件 (如 SQLite 数据库)
│   ├── db_models/           # 数据库模型定义 (ORM)
│   ├── logs/                # 日志文件输出目录
│   ├── middleware/          # 中间件定义 (如认证、日志记录)
│   ├── migrations/          # 数据库迁移脚本 (如 Alembic)
│   └── services/            # 业务逻辑服务层
├── frontend/                 # 前端代码目录 (如果前后端分离)
│   ├── app.py              # 前端应用入口 (如 Gradio)
│   ├── handlers/           # 前端事件处理逻辑
│   └── ui/                 # 用户界面定义
│       └── pages/          # 页面布局
├── shared/                   # 前后端共享代码 (如数据模型、通用函数)
│   └── schemas.py          # 数据传输对象 (DTO) / Pydantic 模型
└── tests/                    # 测试代码 (可选)
    └── ...
```

**开发流程**

**1. 设计业务逻辑 (Service Layer):**

*   **位置**: `backend/services/service_name.py` (例如 `backend/services/user_service.py`)
*   **原则**:
    *   专注于业务逻辑本身，与 FastAPI 框架无关。
    *   函数参数和返回值使用简单的 Python 类型或 Pydantic 模型实例。
    *   使用 `async def` 定义异步函数（如果涉及 I/O 操作）。
    *   编写清晰的函数文档字符串 (Docstring)。
    *   遵循 `AI编程规范` (命名、类型提示、错误处理等)。
*   **示例 (User Service)**:
    ```python
    # backend/services/user_service.py

    from typing import Dict, Any, List, Optional
    from backend.db_models.user import User as UserDBModel # 引入数据库模型
    from sqlmodel import Session, select # 假设使用 SQLModel

    class UserService:
        def __init__(self, session: Session):
            self.session = session # 依赖注入 Session

        def get_user_by_id(self, user_id: int) -> Optional[UserDBModel]:
            """
            根据 ID 获取用户。

            Args:
                user_id (int): 用户 ID。

            Returns:
                Optional[UserDBModel]: 用户数据库模型实例，未找到则返回 None。
            """
            statement = select(UserDBModel).where(UserDBModel.id == user_id)
            return self.session.exec(statement).first()

        def create_user(self, username: str, email: str) -> UserDBModel:
            """
            创建新用户。

            Args:
                username (str): 用户名。
                email (str): 邮箱。

            Returns:
                UserDBModel: 保存到数据库的用户实例。
            """
            # ... 实现创建和保存逻辑 ...
            new_user = UserDBModel(username=username, email=email)
            self.session.add(new_user)
            self.session.commit()
            self.session.refresh(new_user) # 获取数据库生成的 ID 等
            return new_user

        # ... 其他方法如 get_all_users, update_user, delete_user ...
    ```
    *   **注意**: Service 类通常会接收数据库 Session 或其他依赖项作为构造函数参数，实现依赖注入。业务逻辑层直接操作数据库模型 (`UserDBModel`)。

**2. 定义共享模型 (Schemas):**

*   **位置**: `shared/` 目录下,**按 API 端点模块拆分**
    *   **拆分规则**: 每个 API 端点文件 (`backend/api/endpoints/xxx.py`) 对应一个共享模型文件 (`shared/xxx.py`)
    *   **示例映射**:
        *   `backend/api/endpoints/user.py` → `shared/user.py`
        *   `backend/api/endpoints/chat.py` → `shared/chat.py`
        *   `backend/api/endpoints/llm_setting.py` → `shared/llm_setting.py`
    *   **通用模型**: 多个端点共用的模型（如 `MessageResponse`, `ErrorResponse`）保留在 `shared/schemas.py`

*   **原则**:
    *   **只定义用于 API 交互的请求体和响应体模型**。
    *   **不得在 API 端点中直接使用数据库模型 (`backend/db_models` 中的模型) 进行校验或序列化**。API 端点必须使用 `shared/` 中定义的模型。
    *   使用 `pydantic.BaseModel` 定义请求体、响应体。
    *   为 API 端点提供数据校验和序列化。
    *   响应模型通常不包含敏感字段（如密码哈希),或使用 `Field(exclude=True)` 排除。
    *   **枚举类型**: 如果请求体包含枚举字段,必须在对应的 `shared/xxx.py` 文件中定义枚举类。

*   **示例 (User Schemas - 拆分后)**:
    ```python
    # shared/user.py  # 对应 backend/api/endpoints/user.py

    from pydantic import BaseModel, Field
    from typing import Optional
    from datetime import datetime

    # --- 请求体模型 (用于创建/更新) ---
    class UserCreate(BaseModel):
        username: str = Field(..., min_length=3, max_length=50, description="用户名")
        email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$', description="邮箱地址")
        password: str = Field(..., min_length=8, description="密码")

    class UserUpdate(BaseModel):
        username: Optional[str] = Field(None, min_length=3, max_length=50, description="用户名")
        email: Optional[str] = Field(None, regex=r'^[\w\.-]+@[\w\.-]+\.\w+$', description="邮箱地址")

    # --- 响应体模型 (用于返回给客户端) ---
    class UserResponse(BaseModel):
        id: int
        username: str
        email: str
        created_at: datetime
        # 注意：不包含 'password' 等敏感信息

        class Config:
            from_attributes = True  # 允许从 ORM 对象创建
    ```

    ```python
    # shared/llm_setting.py  # 对应 backend/api/endpoints/llm_setting.py

    from datetime import datetime
    from typing import Optional
    from pydantic import BaseModel
    from enum import Enum

    # --- 枚举定义 ---
    class LLMProvider(str, Enum):
        OPENAI = "OpenAI"
        OLLAMA = "Ollama"

    # --- 请求体模型 ---
    class LLMConfigCreate(BaseModel):
        provider: LLMProvider
        model_name: str
        api_key: str
        base_url: Optional[str] = None

    # --- 响应体模型 ---
    class LLMConfigResponse(BaseModel):
        id: int
        provider: LLMProvider
        model_name: str
        base_url: Optional[str]
        created_at: datetime
        updated_at: datetime

        class Config:
            from_attributes = True

    class LLMTestResponse(BaseModel):
        success: bool
        message: Optional[str] = None
    ```

    ```python
    # shared/schemas.py  # 通用响应模型

    from pydantic import BaseModel

    class MessageResponse(BaseModel):
        """通用消息响应（用于删除、更新等操作）"""
        message: str

    class HealthResponse(BaseModel):
        """健康检查响应"""
        status: str
        service: str
        database: str

    class ErrorResponse(BaseModel):
        """错误响应（FastAPI 会自动处理,此处用于文档）"""
        detail: str

    __all__ = ["MessageResponse", "HealthResponse", "ErrorResponse"]
    ```
    *   **注意**: `UserResponse` 不包含 `password` 字段，确保敏感信息不被暴露。`from_attributes=True` 对于从 ORM 模型（如 SQLModel）实例创建 Pydantic 响应模型非常有用。

**3. 创建 API 端点 (Endpoint Layer):**

*   **位置**: `backend/api/endpoints/module_name.py` (例如 `backend/api/endpoints/user.py`)
*   **原则**:
    *   使用 `fastapi.APIRouter` 定义路由。
    *   **负责数据校验**：使用 `shared/module_name.py` 中定义的**请求体模型**。
    *   **负责返回响应**：使用 `shared/module_name.py` 中定义的**响应体模型**。
    *   负责调用服务层函数、处理异常。
    *   使用 `response_model` 指定响应格式（必须是 `shared/` 中的模型）。
    *   遵循 `AI编程规范`。
*   **示例 (LLM Setting Endpoints - 使用拆分后的模型)**:
    ```python
    # backend/api/endpoints/llm_setting.py

    from fastapi import APIRouter, HTTPException
    from typing import List
    from backend.services.llm_setting_service import LLMSettingService
    from backend.db_models.user_config import LLMConfig  # 数据库模型
    from shared.llm_setting import (  # 从对应的 shared 文件导入
        LLMConfigCreate,
        LLMConfigResponse,
        LLMTestResponse
    )

    router = APIRouter(prefix="/settings/llm", tags=["llm-setting"])

    @router.post("", response_model=LLMConfigResponse)
    def create_llm_config(config_data: LLMConfigCreate):
        """创建 LLM 配置"""
        service = LLMSettingService()
        try:
            # 调用服务层,服务层内部使用数据库模型
            saved_config = service.create(
                provider=config_data.provider.value,  # 枚举转字符串
                model_name=config_data.model_name,
                api_key_input=config_data.api_key,
                base_url=config_data.base_url
            )
            # 返回数据库模型,FastAPI 自动转为 LLMConfigResponse
            return saved_config
        except ValueError as e:
            raise HTTPException(status_code=400, detail=str(e))
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"创建失败: {str(e)}")

    @router.post("/{config_id}/test", response_model=LLMTestResponse)
    def test_existing_config(config_id: int):
        """测试已存在的 LLM 配置"""
        service = LLMSettingService()
        try:
            config = service.get_by_id(config_id)
            if not config:
                raise HTTPException(status_code=404, detail="配置不存在")
            
            test_result = service.test_connection(
                provider=config.provider,
                model_name=config.model_name,
                api_key_input=config.api_key,
                base_url=config.base_url
            )
            
            if test_result["success"]:
                return {"success": True, "message": test_result["message"]}
            else:
                raise HTTPException(status_code=400, detail=test_result["message"])
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"测试失败: {str(e)}")

    @router.get("", response_model=List[LLMConfig])
    def list_llm_configs():
        """列出所有 LLM 配置"""
        service = LLMSettingService()
        try:
            configs = service.get_all()
            return configs
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"获取列表失败: {str(e)}")
    ```
    *   **注意**: API 端点层负责调用服务层 (`UserService`) 的方法。它接收 `shared.schemas.UserCreate` 进行请求体校验，并使用 `shared.schemas.UserResponse` 作为返回类型。服务层内部操作数据库模型，API 层负责将数据库模型转换为共享的响应模型（利用 `from_attributes=True`）。

**4. 聚合 API 路由 (API Router):**

*   **位置**: `backend/api/api_router.py`
*   **原则**:
    *   创建主 `APIRouter` 实例 (通常不设置 `prefix`)。
    *   使用 `include_router` 将各功能模块的路由器聚合进来。
*   **示例**:
    ```python
    # backend/api/api_router.py

    from fastapi import APIRouter
    from backend.api.endpoints import user # 导入端点路由器

    api_router = APIRouter(tags=["api"])
    api_router.include_router(user.router) # 包含端点路由
    # api_router.include_router(product.router) # 包含其他模块路由

    ```
    *   **注意**: 这里没有给 `user.router` 添加额外前缀，所以用户相关的 API 路径就是 `/api/users/...`。

**5. 启动 FastAPI 应用 (Main):**

*   **位置**: `backend/main.py`
*   **原则**:
    *   创建 `FastAPI` 实例。
    *   添加中间件（如 `CORSMiddleware`）。
    *   使用 `app.include_router(api_router, prefix="/api")` 加载 API 路由。
    *   通过 `uvicorn` 启动应用。
*   **示例**:
    ```python
    # backend/main.py

    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    from backend.api.api_router import api_router
    from backend.config.settings import settings

    app = FastAPI(title="My App API")

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.ALLOWED_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.include_router(api_router, prefix="/api") # 加载路由

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="127.0.0.1", port=8000)

    ```
    *   **注意**: 最终的 API 路径会是 `/api/users/...`。

**关键要点**

1.  **分离**: 业务逻辑 (`services`) 和 API 接口 (`api/endpoints`) 必须分离。
2.  **聚合**: 使用 `api_router.py` 作为 `main.py` 和具体 `endpoints` 之间的桥梁。
3.  **模型职责分离与组织**:
    *   **共享模型 (`shared/`)**: 
        *   **按端点拆分**: 每个 API 端点对应一个模型文件 (`shared/endpoint_name.py`)
        *   **仅用于 API**: 用于请求体校验和响应体定义
        *   **枚举定义**: 请求体/响应体使用的枚举类型必须在对应 `shared/` 文件中定义
        *   **通用模型**: 如 `MessageResponse`, `ErrorResponse` 保留在 `shared/schemas.py`
    *   **数据库模型 (`backend/db_models`)**: 仅用于数据库交互和业务逻辑实现
    *   **API 端点**: 必须使用共享模型,**不得**直接使用数据库模型
4.  **导入规范**: API 端点从对应的 `shared/endpoint_name.py` 导入模型,例如:
    ```python
    # backend/api/endpoints/chat.py
    from shared.chat import ChatSessionCreate, ChatSessionRead, ChatTurnRequest
    
    # backend/api/endpoints/llm_setting.py  
    from shared.llm_setting import LLMConfigCreate, LLMConfigResponse, LLMTestResponse
    ```
5.  **规范**: 时刻遵守 `AI编程规范`,确保代码质量和一致性。
6.  **测试**: 分离后的 `services` 层更容易进行单元测试。
7.  **依赖注入**: 在 API 端点中使用 `Depends` 来注入服务层所需的依赖（如数据库 Session）,提高代码的可测试性和解耦性。
8.  **响应体安全**: 
    *   响应模型不得包含敏感字段（密码、密钥等）
    *   使用 `Config.from_attributes = True` 支持从 ORM 模型转换
    *   明确定义返回字段,避免意外暴露数据

**前后端验证流程**

```
┌─────────────┐
│ 前端 (Gradio)│
└──────┬──────┘
       │ 1. 用户提交表单
       ▼
┌──────────────────────┐
│ HTTP Request         │
│ POST /api/users      │
│ Body: {              │
│   "username": "...", │
│   "email": "...",    │
│   "password": "..."  │
│ }                    │
└──────┬───────────────┘
       │ 2. 请求发送到后端
       ▼
┌──────────────────────┐
│ FastAPI Endpoint     │
│ @router.post("")     │
│ def create_user(     │
│   user_data:         │
│     UserCreate       │ ← 使用 shared/user.py 中的模型
│ )                    │
└──────┬───────────────┘
       │ 3. Pydantic 自动校验
       │    - 类型检查
       │    - 字段验证 (min_length, regex 等)
       ▼
┌──────────────────────┐
│ Service Layer        │
│ UserService.create() │ ← 使用 db_models 中的数据库模型
└──────┬───────────────┘
       │ 4. 保存到数据库
       ▼
┌──────────────────────┐
│ Database (SQLite)    │
└──────┬───────────────┘
       │ 5. 返回数据库模型实例
       ▼
┌──────────────────────┐
│ FastAPI Endpoint     │
│ return user_db_model │ ← FastAPI 自动转换为 UserResponse
└──────┬───────────────┘
       │ 6. 序列化为 JSON (使用 response_model)
       ▼
┌──────────────────────┐
│ HTTP Response        │
│ Status: 200          │
│ Body: {              │
│   "id": 1,           │
│   "username": "...", │
│   "email": "...",    │
│   "created_at": "..."│
│ }                    │ ← 不包含 password 字段
└──────┬───────────────┘
       │ 7. 响应返回前端
       ▼
┌─────────────┐
│ 前端 (Gradio)│ ← 更新 UI 显示结果
└─────────────┘
```

**验证层次说明**:
1. **前端验证**: Gradio 组件的基础验证 (可选,用户体验优化)
2. **Pydantic 验证**: FastAPI 使用 `shared/` 中的模型自动校验请求体
3. **业务逻辑验证**: Service 层的业务规则检查
4. **数据库约束**: 数据库层的完整性约束

**错误处理链**:
```
前端表单 → Pydantic 校验失败 → 422 Unprocessable Entity
          → 业务逻辑失败 → 400 Bad Request (HTTPException)
          → 数据库错误 → 500 Internal Server Error
```