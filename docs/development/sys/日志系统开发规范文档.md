# 本地 AI Agent 项目 - 日志系统开发规范文档

## 1. 核心思想

本项目日志系统旨在建立一个**清晰、高效、安全**的日志记录机制，以支持本地 AI Agent 框架的开发调试、运行监控和问题追溯。

- **后端集中管理**：仅后端负责日志记录，覆盖 API、Service、启动等所有后端模块。
- **环境自适应**：通过 `RUN_ENV` 环境变量自动切换日志级别和输出方式，平衡开发效率与生产性能。
- **安全第一**：严格禁止记录敏感信息，确保日志内容不包含用户隐私或系统密钥。
- **结构化记录**：采用统一格式，便于日志聚合、分析和检索。
- **调试友好**：在开发模式下，记录足够的非敏感上下文信息，方便问题定位。

## 2. 规范要求

### 2.1 日志级别使用规范

| 级别 | 触发场景 | 记录模块 | 示例 |
| :--- | :--- | :--- | :--- |
| `INFO` | API 接口调用摘要（请求方法、路径、状态码、耗时） | FastAPI 中间件 | `INFO - API request: POST /chat - status_code=200 - 0.15s` |
| `DEBUG` | Service 层业务流程细节（关键参数ID、步骤状态、非敏感摘要） | Service 函数 | `DEBUG - Starting LLM call for chat_id=abc, model=gpt-4o, prompt_length=150` |
| `WARNING` | 非致命业务警告（配额超限、使用备用方案） | Service/API 层 | `WARNING - User quota exceeded for user_id=123, using fallback model` |
| `ERROR` | 业务逻辑或外部服务错误（DB 查询失败、LLM 调用异常） | Service/API 层 | `ERROR - Database query failed: ...` |
| `CRITICAL` | 系统级崩溃（DB 连接失败、服务无法启动） | 启动脚本/核心组件 | `CRITICAL - Failed to connect to database, shutting down.` |

### 2.2 记录内容安全与调试规范

- **❌ 禁止记录**：
  - 用户输入/输出的完整内容（prompt, response）。
  - API Key、密码等敏感配置。
  - 完整的错误堆栈信息（除非是 `ERROR` 级别并使用 `exc_info=True`）。
- **✅ 允许记录（开发模式）**：
  - 用户 ID、会话 ID、聊天 ID 等标识符。
  - 操作摘要（如“用户创建了新聊天”）。
  - 非敏感的输入摘要（如 `prompt_length=150`，而非 `prompt_content="..."`）。
  - 错误的类型和简要描述（如“数据库连接超时”）。
- **✅ 允许记录（生产模式）**：
  - 用户 ID、会话 ID、聊天 ID 等标识符。
  - 操作摘要（如“用户创建了新聊天”）。
  - 错误的类型和简要描述。

### 2.3 日志格式规范

- **格式 (开发/生产)**：
  - **文本格式 (默认/备选)**：`[%(asctime)s] %(name)s:%(levelname)s - %(message)s`
  - **JSON 格式 (推荐)**：结构化 JSON 对象（见第 6 节）。
- **时间戳**：`YYYY-MM-DD HH:MM:SS,mmm` 格式。
- **Logger 名称**：使用 `logging.getLogger(__name__)`，例如 `backend.api.endpoints.chat`。
- **消息内容**：使用占位符（如 `logger.info("User ID: %s", user_id)`），避免字符串拼接。

### 2.4 文件管理规范

- **存储路径**：`backend/logs/` 目录下。
- **文件命名**：`backend/logs/app.log`
- **轮转策略**：使用 `RotatingFileHandler`，单文件最大 10MB，保留 5 个备份。

## 3. 实现方法与流程

### 3.1 配置驱动

- **配置文件**：在 `backend/config/log_config.yaml` 中定义日志相关参数，如日志级别、格式、文件路径、轮转大小等。
- **环境变量**：通过 `RUN_ENV` (development/production) 决定最终的日志级别和输出方式。

### 3.2 统一初始化

- **初始化模块**：创建 `backend/core/logger.py` 作为日志系统的唯一入口。
- **初始化函数**：`setup_logging()` 函数读取 `log_config.yaml`，根据 `RUN_ENV` 设置日志级别、创建 Handler、Formatter，并附加到 `backend` logger。
- **启动时调用**：在 `backend/main.py` 的 `create_app()` 之前调用 `setup_logging()`。

### 3.3 FastAPI 集成

- **中间件**：创建 `backend/middleware/logging_middleware.py`。
- **功能**：捕获每个请求，记录 `method`, `path`, `status_code`, `process_time`。
- **日志器**：使用 `logging.getLogger("backend.api")`。
- **注册**：在 `backend/main.py` 的 `create_app()` 函数中注册该中间件。

### 3.4 Service 层使用

- **导入**：在 `backend/services/*.py` 文件中，使用 `import logging; logger = logging.getLogger(__name__)` 获取 logger。
- **记录**：在函数入口、关键步骤、异常捕获处，按照规范使用相应日志级别。

## 4. 具体细节

### 4.1 配置文件示例 (`backend/config/log_config.yaml`)

```yaml
# 日志系统配置
default_level: "INFO"
# 输出格式: "text" 或 "json"
format_type: "json" # 推荐
text_format: "[%(asctime)s] %(name)s:%(levelname)s - %(message)s"
json_format: 
  timestamp: "%(asctime)s"
  level: "%(levelname)s"
  logger: "%(name)s"
  message: "%(message)s"
filename: "./logs/app.log" # 相对于 backend 目录
max_bytes: 10485760  # 10MB
backup_count: 5
development:
  level: "DEBUG"
  # 开发时可选：是否输出到控制台
  console: true
  console_format_type: "text" # 控制台输出文本更直观
production:
  level: "INFO"
  console: false
```

### 4.2 代码实现示例

- **`backend/core/logger.py`**：
  - `setup_logging()` 函数：解析 `log_config.yaml` 和 `RUN_ENV`，根据 `format_type` 选择 `TextFormatter` 或 `JSONFormatter`，配置 logger。
- **`backend/middleware/logging_middleware.py`**：
  - `logging_middleware(request, call_next)` 函数：记录请求摘要，使用 JSON 格式记录结构化信息。
- **`backend/services/chat_service.py`**：
  - `logger = logging.getLogger(__name__)` 并在函数中使用 `logger.debug()`, `logger.info()`, `logger.error()`。

### 4.3 与开发规范的结合

- **遵循 `AI编程规范.md`**：
  - 使用 `import logging; logger = logging.getLogger(__name__)`。
  - 日志消息使用占位符，避免字符串拼接。
  - 在 `ERROR` 级别日志中使用 `exc_info=True` 记录堆栈。
- **遵循 `后端服务开发规范`**：
  - 日志初始化逻辑放在 `core` 目录。
  - 中间件放在 `middleware` 目录。
  - Service 层专注于业务逻辑，日志作为辅助信息。

### 4.4 启动流程

- **`backend/main.py`**：
  - **步骤1**：检查并创建 `./logs` 目录。
  - **步骤2**：调用 `setup_logging()`。
  - **步骤3**：创建 `app` 并注册中间件。
  - **步骤4**：记录服务启动成功的 `INFO` 日志。

---

## 5. 合理的实现流程

1.  **创建配置文件**：在 `backend/config/` 目录下创建 `log_config.yaml`，定义日志配置结构。
2.  **创建日志模块**：在 `backend/core/` 目录下创建 `logger.py`，实现 `setup_logging()` 函数，负责读取配置、根据环境变量设置级别、创建 Handler 和 Formatter（支持文本和 JSON）。
3.  **创建中间件**：在 `backend/middleware/` 目录下创建 `logging_middleware.py`，实现 `async logging_middleware` 函数，记录请求摘要，使用结构化方式（如字典）记录信息。
4.  **修改主入口**：在 `backend/main.py` 中：
    - 在 `create_app()` 之前，添加目录检查和 `setup_logging()` 的调用。
    - 在 `create_app()` 函数内部，使用 `app.add_middleware()` 注册步骤 3 创建的中间件。
5.  **在 Service 中使用**：在 `backend/services/*.py` 文件中，按规范引入和使用 `logger`。
6.  **测试验证**：启动服务，切换 `RUN_ENV` 环境变量，观察日志输出级别和位置是否符合预期。在开发模式下，尝试触发 API 和 Service 中的日志，确认信息内容符合安全和调试要求。

---

## 6. 优化日志聚合与分析流程 (拓展)

为了提升日志的可读性、可分析性和故障排查效率，建议采用以下优化措施。

### 6.1 结构化日志输出 (核心优化)

- **采用 JSON 格式**：将日志消息本身结构化为 JSON 对象，而不是纯文本。这比解析固定格式的文本更可靠，也更易于工具处理。
    - **格式示例**：
        ```json
        {"timestamp": "2026-01-02T21:30:45.123", "level": "INFO", "logger": "backend.api", "message": "API request", "method": "POST", "path": "/chat", "status_code": 200, "process_time": 0.15, "user_id": 123}
        {"timestamp": "2026-01-02T21:30:46.456", "level": "DEBUG", "logger": "backend.services.chat_service", "message": "Starting LLM call", "chat_id": "abc123", "model": "gpt-4o", "prompt_length": 150}
        ```
    - **实现**：在 `backend/core/logger.py` 中，使用 `python-json-logger` 库或自定义 `logging.Formatter` 的子类来生成 JSON 格式的日志。
- **统一字段命名**：为关键信息（如 `timestamp`, `level`, `logger`, `user_id`, `chat_id`, `process_time`）定义统一的字段名，方便后续查询和聚合。
- **上下文注入**：在请求处理链中，将关键上下文（如 `user_id`, `request_id`）注入到日志记录中，确保每条日志都携带足够的上下文信息。

### 6.2 本地日志分析工具链 (便捷性优化)

- **命令行工具 (grep, awk, sed)**：
    - **优点**：无需额外安装，系统自带。
    - **用途**：快速查找特定错误、统计特定请求次数等。
    - **示例**：
        ```bash
        # 查找所有 ERROR 级别日志 (JSON 格式)
        grep '"level": "ERROR"' backend/logs/app.log
        # 查找特定用户 (user_id=123) 的日志
        grep '"user_id": 123' backend/logs/app.log
        # 统计 200 状态码的请求数 (JSON 格式)
        grep '"status_code": 200' backend/logs/app.log | wc -l
        ```
- **日志查看器 (less, tail -f)**：
    - **优点**：实时查看、分页浏览。
    - **用途**：开发调试时实时监控日志。
    - **示例**：
        ```bash
        # 实时追加查看日志
        tail -f backend/logs/app.log
        ```
- **轻量级日志分析工具 (jq)**：
    - **jq**：强大的 JSON 处理工具，可以对 JSON 格式的日志进行复杂的查询、过滤和格式化。
        - **示例**：找出处理时间超过 1 秒的请求
            ```bash
            cat backend/logs/app.log | jq -c 'select(.process_time > 1.0)'
            ```
        - **示例**：提取所有 API 请求的路径和状态码
            ```bash
            cat backend/logs/app.log | jq -r '[.path, .status_code] | @csv'
            ```
        - **示例**：统计各 API 路径的请求次数
            ```bash
            cat backend/logs/app.log | jq -r '.path' | sort | uniq -c | sort -nr
            ```
- **自定义分析脚本**：编写 Python 脚本（例如 `backend/scripts/analyze_logs.py`），利用 `pandas` 等库读取 JSON 日志，进行更复杂的统计分析（如性能趋势、错误率统计、用户行为分析）。

### 6.3 分析方法与策略 (效率优化)

- **建立日志索引/摘要**：对于非常大的日志文件，可以定期运行脚本，提取关键指标（如错误次数、平均响应时间、请求量）并写入到小的摘要文件或 CSV 中，便于快速概览。
- **日志轮转与归档**：继续使用 `RotatingFileHandler`，但可以考虑在轮转时，对旧的日志文件进行压缩（如 `.log.gz`），并定期清理过期的日志。
- **使用 IDE 插件**：部分 IDE（如 VS Code）有日志高亮、过滤插件，可以在 IDE 内直接分析日志文件。

### 6.4 与现有规范的结合

- **遵循 `AI编程规范.md`**：在结构化日志中，确保 JSON 字段名符合命名规范（如 `snake_case`）。
- **配置化**：在 `log_config.yaml` 中增加 `format_type` 选项，允许选择输出格式（`text` 或 `json`），推荐使用 `json` 以支持优化。

---

此文档旨在为开发者提供一个清晰、可执行的日志系统开发指南，确保项目代码的一致性、可维护性和安全性。在进行 AI 辅助编码时，应严格参照此规范，确保生成的代码符合上述所有要求，特别是关于结构化日志和分析流程的优化建议。